{"version":3,"sources":["Redux/Actions/actionTypes.js","Components/Cell.tsx","Components/Graph.tsx","Components/SideBar.tsx","Helpers/Visualizer/Visualizer.tsx","Helpers/Vertex/Vertex.tsx","Helpers/Animations/Frame.tsx","Helpers/AdjList/AdjList.tsx","Helpers/Animations/Animator.tsx","Redux/Store/store.js","Redux/Reducer/reducer.js","App.tsx","reportWebVitals.ts","index.tsx"],"names":["actions","editCell","blockOrUnBlock","setStart","setEnd","clearFrames","clear","e","id","type","ctrlKey","buttons","preventDefault","button","connect","state","props","dispatch","payload","String","fromCharCode","useSelector","blocked","gameboard","get","start","startVertexid","end","endVertexid","focusedNode","animator","visited","visitedNodes","has","inSolution","solutionNodes","clearOnEdit","frames","size","className","onContextMenu","onClick","onMouseDown","onMouseEnter","style","backgroundColor","getBackgroundColor","width","height","minHeight","minWidth","fontSize","padding","margin","createRows","current","rows","count","currentRow","newCell","push","unshift","map","row","index","marginRight","defAlgs","currentFrame","isPaused","createGameBoard","pause","play","resetAnimator","setAlg","alg","useState","setSize","display","marginTop","marginLeft","textAlign","color","onSubmit","console","log","maxWidth","placeholder","onChange","newHeight","parseInt","target","value","newWidth","name","VisualizerVertex","adjList","gameEdges","curr_coordinates","getCoordinates","this","x","y","right","rightBlocked","left","leftBlocked","top","topBlocked","bottom","bottomBlocked","edges","edge","filter","vEdge","vertexId","Math","ceil","Frame","animation","processed","AdjList","set","vertexID","edgeID","addEdge","removeEdge","startID","Map","queue","length","queuedItem","pop","last","path","getEdges","some","item","undefined","stack","stackedItem","list","vertices","vertex","addVertex","GraphAnimator","addAnimation","getFrame","getAnimation","graph","i","animations","delete","Error","frame","algs","AbsVisualizer","immerable","createGameboard","gameBoard","currentAlg","Visualizer","store","createStore","action","produce","draftState","generateFrames","processFrame","node","a","unsubscribe","subscribe","getState","requestAnimationFrame","animatorEventTrigger","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","enableMapSet","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4RAAaA,EAEI,cAFJA,EAMC,WANDA,EAOD,SAPCA,EAQW,qBARXA,EAWD,SAXCA,EAeF,QAfEA,EAgBH,OAhBGA,EAiBS,UAjBTA,EAkBO,iBAlBPA,EAmBI,cAnBJA,EAoBM,gB,OChBnB,SAASC,EAAUC,EAAqBC,EAAeC,EAAaC,EAAkBC,GAClF,OAAO,SAACC,EAAkGC,GACxF,cAAXD,EAAEE,MAAmC,eAAXF,EAAEE,KACxBF,EAAEG,SAAuB,IAAZH,EAAEI,UAEdJ,EAAEK,iBAEFV,EAAeM,GACZF,GAAOD,KAGC,gBAAXE,EAAEE,MAENF,EAAEK,iBACFR,EAAOI,GACJF,GAAOD,KAEM,UAAXE,EAAEE,OACS,IAAbF,EAAEM,QAAiBN,EAAEG,UAEpBP,EAASK,GACNF,GAAOD,OAsFXS,mBAff,SAAyBC,EAAYC,GACjC,OAAO,eACAA,MAIX,SAA4BC,GACxB,MAAQ,CACJf,eAAgB,SAACM,GAAD,OAAeS,EAAS,CAACR,KAAMT,EAA2BkB,QAAS,CAACV,SACpFL,SAAU,SAACK,GAAD,OAAgBS,EAAS,CAACR,KAAMT,EAAkBkB,QAAS,CAACV,SACtEJ,OAAQ,SAACI,GAAD,OAAgBS,EAAS,CAACR,KAAMT,EAAgBkB,QAAS,CAACV,SAClEH,YAAa,kBAAMY,EAAS,CAACR,KAAMT,QAI5Bc,EAhFf,SAAcE,GACCG,OAAOC,aAAa,KAA/B,IACOZ,EAAMQ,EAANR,GAF4G,EAItCa,aACzE,SAACN,GACG,MAAQ,CACJO,QAAUP,EAAMQ,UAAUC,IAAIhB,GAAIU,QAAQI,QAC1CG,MAAOV,EAAMW,cACbC,IAAKZ,EAAMa,YACXC,YAAad,EAAMe,SAASD,YAC5BE,QAAShB,EAAMe,SAASE,aAAaC,IAAIzB,GACzC0B,WAAYnB,EAAMe,SAASK,cAAcF,IAAIzB,GAC7C4B,YAAarB,EAAMe,SAASO,OAAOC,KAAO,MAT/ChB,EAJ4G,EAI5GA,QAASG,EAJmG,EAInGA,MAAOE,EAJ4F,EAI5FA,IAAKE,EAJuF,EAIvFA,YAAaE,EAJ0E,EAI1EA,QAASG,EAJiE,EAIjEA,WAAYE,EAJqD,EAIrDA,YAqC9D,OACI,qBAAKG,UAAW,OACXC,cAAe,SAACjC,GAAD,OAAON,EAASe,EAAMd,eAAgBc,EAAMb,SAAUa,EAAMZ,OAAQY,EAAMX,YAAa+B,EAAhFnC,CAA6FM,EAAGC,IACtHiC,QAAS,SAAClC,GAAD,OAAQN,EAASe,EAAMd,eAAgBc,EAAMb,SAAUa,EAAMZ,OAAQY,EAAMX,YAAa+B,EAAhFnC,CAA6FM,EAAGC,IACjHkC,YAAa,SAACnC,GAAD,OAAQN,EAASe,EAAMd,eAAgBc,EAAMb,SAAUa,EAAMZ,OAAQY,EAAMX,YAAa+B,EAAhFnC,CAA6FM,EAAGC,IACrHmC,aAAc,SAACpC,GAAD,OAAQN,EAASe,EAAMd,eAAgBc,EAAMb,SAAUa,EAAMZ,OAAOY,EAAMX,YAAa+B,EAA/EnC,CAA4FM,EAAGC,IAJ1H,SAMI,sBAAKoC,MAAO,CACRC,gBAhCa,SAACvB,EAAkBG,EAAeE,GACvD,IAAIkB,EAAkB,YAoBtB,OAlBGlB,IAAQE,GAAeK,GAAc1B,GAAIiB,GAASjB,GAAImB,EACrDkB,EAAkB,aAEdrC,IAAOqB,GAAeF,IAAOE,EACjCgB,EAAkB,QAEdpB,IAAUjB,EACdqC,EAAkB,SAEdlB,IAAQnB,EACZqC,EAAkB,SAEbd,EACLc,EAAkB,YAEbvB,IACLuB,EAAkB,SAEfA,EAWkBC,CAAmBxB,EAASG,EAAOE,GACpDoB,MAAQ,MACRC,OAAQ,MACRC,UAAW,OACXC,SAAS,OACTC,SAAU,OACVC,QAAS,IACTC,OAAQ,KARZ,UAUK5B,IAAQjB,EAAK,QAAS,GAAImB,IAAMnB,EAAK,MAAO,WCpF7D,SAAS8C,EAAWhB,GAKhB,IAJA,IAAIiB,EAAU,EACVC,EAAO,GACPC,EAAe,EAEbF,EAAUjB,EAAKU,QAAO,CAEzB,IADA,IAAIU,EAAa,GACXD,IAAUF,EAAU,GAAKjB,EAAKS,OAAM,CACtC,IAAIY,EAA8B,cAAC,EAAD,CAAMnD,GAAIiD,GAAYA,GACxDC,EAAWE,KAAKD,GAChBF,IACAE,EAAU,KAEdH,EAAKK,QAAQH,GACbA,EAAa,GACbH,IAGH,OAAOC,EAAKM,KAAI,SAACC,EAAIC,GACjB,OACI,qBAAKzB,UAAW,MAAhB,SACKwB,GADuB,OAASC,MA+BlClD,mBAZf,SAAyBC,GAErB,MAAQ,CACJuB,KAAMvB,EAAMuB,SAKpB,SAA4BrB,GACxB,MAAQ,KAGGH,EAvBf,SAAgBE,GAIR,OACI,qBAAKuB,UAAU,QAAQK,MAAO,CAACqB,YAAa,QAA5C,SACKX,EAAWtC,EAAMsB,W,QCuFnBxB,IC1HVoD,ED0HUpD,eApBf,SAAyBC,GACrB,MAAQ,CACJuB,KAAMvB,EAAMuB,KACZ6B,aAAcpD,EAAMe,SAASqC,aAC7BC,SAAUrD,EAAMe,SAASsC,aAIjC,SAA4BnD,GACxB,MAAQ,CACJoD,gBAAiB,SAAC/B,GAAD,OAA2CrB,EAAS,CAACR,KAAMT,EAAqBkB,QAAQ,eAAKoB,MAC9GgC,MAAO,kBAAMrD,EAAS,CAACR,KAAMT,KAC7BuE,KAAM,WAAOtD,EAAS,CAACR,KAAMT,KAE7BwE,cAAe,kBAAMvD,EAAS,CAACR,KAAMT,KACrCyE,OAAQ,SAACC,GAAD,OAAgBzD,EAAS,CAACR,KAAMT,EAAgBkB,QAAS,CAACwD,IAAKA,SAKhE5D,EAxHf,SAAiBE,GAA0B,IAAD,EACd2D,mBAAS,CAAC3B,OAAQ,EAAGD,MAAO,IADd,mBAC/BT,EAD+B,KACzBsC,EADyB,KAGtC,OACI,gCAEI,qBAAKhC,MAAO,CAACiC,QAAS,QAAtB,SACI,qBAAIjC,MAAO,CACPS,OAAQ,IACRyB,UAAW,OACXC,WAAY,OACZ3B,QAAS,IACT4B,UAAW,OACXC,MAAO,OANX,UAQI,2CACI,6BAAI,6BAAI,4DAEZ,yCACI,6BAAI,6BAAI,6DAEZ,qDACI,6BAAI,6BAAI,oGAMpB,qBAAKrC,MAAO,CAACiC,QAAS,OAAQzB,QAAS,KAAvC,SACI,uBAAMR,MAAO,CACTS,OAAQ,IACRD,QAAS,IACT0B,UAAW,OACXC,WAAY,QAEVG,SAAW,SAAC3E,GACR4E,QAAQC,IAAI,wBACZ7E,EAAEK,iBACFI,EAAMqD,gBAAgB/B,IAThC,UAYI,uBAAOM,MAAO,CAACyC,SAAU,OAAQpB,YAAa,OAAQxD,KAAK,OAAO6E,YAAa,SAAUC,SAAU,SAAChF,GAC5F,IAAIiF,EAAYC,SAASlF,EAAEmF,OAAOC,OAClCf,EAAQ,2BAAItC,GAAL,IAAWU,OAAQwC,QAGlC,uBAAO5C,MAAO,CAACyC,SAAU,OAAQpB,YAAa,OAAQxD,KAAK,OAAO6E,YAAa,QAASC,SAAU,SAAChF,GAC3F,IAAIqF,EAAWH,SAASlF,EAAEmF,OAAOC,OACjCf,EAAQ,2BAAItC,GAAL,IAAWS,MAAO6C,QAGjC,uBAAOnF,KAAK,SAASkF,MAAM,kBAOnC,qBAAK/C,MAAO,CAACiC,QAAS,OAAQzB,QAAS,OAMvC,sBAAKR,MAAO,CAACiC,QAAS,OAAQzB,QAAS,KAAvC,UACI,qBAAKR,MAAO,CAIRS,OAAQ,IACRD,QAAS,IACT0B,UAAW,OACXC,WAAY,QAPhB,SAUI,yBAAQc,KAAK,aAAaN,SAAU,SAAChF,GAAD,OAAOS,EAAMyD,OAAOlE,EAAEmF,OAAOC,QAAjE,UACI,wBAAQA,MAAM,MAAd,iBACA,wBAAQA,MAAM,MAAd,iBACA,wBAAQA,MAAM,SAAd,yBAGR,sBAAK/C,MAAO,CAIRS,OAAQ,IACRD,QAAS,IACT0B,UAAW,OACXC,WAAY,OAPhB,UASI,wBAAQtC,QAASzB,EAAMuD,KAAvB,kBACA,wBAAQ9B,QAASzB,EAAMsD,MAAvB,mBACA,wBAAQ7B,QAASzB,EAAMwD,cAAvB,+B,0EExCPsB,EAAb,8JACI,SAAgBxD,EAAuCyD,GAAmB,IAChE/C,EAAiBV,EAAjBU,OAAQD,EAAST,EAATS,MACXiD,EAAsB,GAerBC,EAAmBH,EAAiBI,eAAeC,KAAK3F,GAAIwC,EAAQD,GACnEqD,EAAOH,EAAPG,EAAEC,EAAKJ,EAALI,EACF/E,EAAW6E,KAAKjF,QAAhBI,QAIDgF,EAASF,EAAE,GAAKC,EAAE,GAAGtD,EAEzB,IAAIzB,GACOgF,EAAQtD,EAAOD,EAAM,GAAKuD,GAASD,EAAEtD,EAAM,CAC1C,IAAIwD,EAAeR,EAAQvE,IAAI8E,GAC5BC,IAAiBA,EAAarF,QAAQI,SACrC0E,EAAUpC,KAAK0C,GAQ/B,IAAIE,EAAQJ,EAAE,GAAKC,EAAE,GAAGtD,EACxB,IAAIzB,EAAQ,CACR,IAAImF,EAAcV,EAAQvE,IAAIgF,GAC3BA,EAAO,GAAKA,GAAQH,EAAE,GAAGtD,GACrB0D,IAAgBA,EAAYvF,QAAQI,SACnC0E,EAAUpC,KAAK4C,GAQ3B,IAAIE,EAAMN,EAAIC,EAAGtD,EACjB,IAAIzB,EAAQ,CACR,IAAIqF,EAAaZ,EAAQvE,IAAIkF,GAC1BA,EAAM1D,EAAOD,EAAM,GACf4D,IAAeA,EAAWzF,QAAQI,SACjC0E,EAAUpC,KAAK8C,GAQ3B,IAAIE,EAASR,GAAIC,EAAE,GAAGtD,EACtB,IAAIzB,EAAQ,CACR,IAAIuF,EAAgBd,EAAQvE,IAAIoF,GAC7BA,EAAS,GACLC,IAAkBA,EAAc3F,QAAQI,SACvC0E,EAAUpC,KAAKgD,GAM3B,OAAOZ,MA3Ef,GAhDA,WAKI,WAAY9E,EAAcV,GAAa,yBAJvCU,QAAU,CAACI,SAAS,GAIkB,KAHtCd,IAAc,EAGwB,KAFtCsG,MAAmB,GAGXX,KAAKjF,QAAUA,EACfiF,KAAK3F,GAAKA,EAPtB,2CAUI,SAAQuG,GACJ,IACOZ,KAAKW,OACJX,KAAKW,MAAMlD,KAAKmD,GAGxB,MAAOxG,GACH4E,QAAQC,IAAI7E,MAjBxB,wBAqBI,SAAWwG,GACP,IACOZ,KAAKW,QACJX,KAAKW,MAAQX,KAAKW,MAAME,QAAO,SAAAC,GAAK,OAAIA,IAAUF,MAG1D,MAAOxG,GACH4E,QAAQC,IAAI7E,MA5BxB,iBAiCI,WACI,OAAO4F,KAAKW,SAlCpB,6BAqCI,SAA6BI,EAAkBlE,EAAgBD,GAC3D,IAAIsD,EAAYc,KAAKC,KAAKF,EAASnE,GAEnC,MAAO,CAACqD,EADQrD,GAASsD,EAAEtD,EAAQmE,GACxBb,SAxCnB,MCJagB,EAKT,WAAYC,EAAmBpG,GAAe,yBAJ9CqG,WAAqB,EAIwB,KAH7CD,UAAY,UAGiC,KAF7CpG,QAAU,GAGNiF,KAAKjF,QAAUA,EACfiF,KAAKmB,UAAYA,GCGZE,EAAb,+JAGI,SAAUtG,EAAcV,GACpB2F,KAAKsB,IAAIjH,EAAI,IAAIsF,EAAiB5E,EAASV,MAJnD,qBAOI,SAAQkH,EAAkBC,GACtBxB,KAAK3E,IAAIkG,GAAUE,QAAQD,KARnC,wBAWI,SAAWD,EAAkBC,GACzBxB,KAAK3E,IAAIkG,GAAUG,WAAWF,KAZtC,iBA4BI,SAAWG,EAAiBnG,EAAYW,GAEpC,IAAIP,EAAU,IAAIgG,IAEdC,EAAqB,GAGrB3F,EAAS,IAAI0F,IAOjB,IAJAC,EAAMpE,KAAK,CAACkE,GAAU,IAIhBE,EAAMC,OAAS,GAAE,CAEnB,IAAIC,EAAaF,EAAMG,MAGnB5E,OAAO,EAAE6E,EAAO,KACpB,GAAGF,EAAW,CAAC,IAAD,cACQA,EADR,GACT3E,EADS,KACA6E,EADA,KASd,GALc,MAAX7E,GACClB,EAAOoF,IAAIpF,EAAOC,KAAM,IAAI+E,EAAM,QAAS,CAAC7G,GAAI+C,KAIjDA,GAAW5B,EAAI,CAGd,IAFA,IAAI0G,EAAO,CAAC9E,GAEN6E,GAAQ,GACVC,EAAKxE,QAAQuE,GACbA,EAAOrG,EAAQP,IAAI4G,GAEvB,MAAO,CAACH,OAAQI,EAAKJ,OAAQI,KAAMA,EAAMhG,OAAQA,GAIrD,IAAIyE,OAAK,EACNxE,IACCwE,EAAQX,KAAK3E,IAAI+B,GAAS+E,SAAShG,EAAM6D,OA5B1B,oBA8BHW,GA9BG,yBA8BXC,EA9BW,QAgCXhF,EAAQE,IAAI8E,IAAUiB,EAAMO,MAAK,SAAAC,GAAI,OAAIA,EAAK,KAAKzB,MAC/CiB,EAAMnE,QAAQ,CAACkD,EAAKxD,KAHhC,IAAI,EAAJ,qBAAuB,IA9BJ,8BAqCnBxB,EAAQ0F,IAAIlE,EAAS6E,GAEzB,MAAO,CAACH,OAAQ,EAAGI,UAAMI,EAAWpG,OAAQA,KAjFpD,iBAqFI,SAAIyF,EAAiBnG,EAAYW,GAC7B,IAAIP,EAAU,IAAIgG,IAEdW,EAAqB,GAErBrG,EAAS,IAAI0F,IAMjB,IAHAW,EAAM9E,KAAK,CAACkE,GAAU,IAGhBY,EAAMT,OAAS,GAAE,CAEnB,IAAIU,EAAcD,EAAMP,MAIpB5E,OAAO,EAAE6E,OAAI,EACjB,GAAGO,EAAY,CAAC,IAAD,cACOA,EADP,GACVpF,EADU,KACD6E,EADC,KASf,GALc,MAAX7E,GACClB,EAAOoF,IAAIpF,EAAOC,KAAM,IAAI+E,EAAM,QAAS,CAAC7G,GAAI+C,KAIjDA,GAAW5B,EAAI,CAEd,IADA,IAAI0G,EAAO,CAAC9E,GACN6E,GAAQ,GACVC,EAAKxE,QAAQuE,GACbA,EAAOrG,EAAQP,IAAI4G,GAEvB,MAAO,CAACH,OAAQI,EAAKJ,OAAQI,KAAMA,EAAMhG,OAAQA,GAIrD,IA1BmB,EA0BfyE,EAAQX,KAAK3E,IAAI+B,GAAS+E,SAAShG,EAAM6D,MA1B1B,cA2BHW,GA3BG,yBA2BXC,EA3BW,QA6BXhF,EAAQE,IAAI8E,IAAU2B,EAAMH,MAAK,SAAAC,GAAI,OAAIA,EAAK,KAAKzB,MACnD2B,EAAM9E,KAAK,CAACmD,EAAKxD,KAHzB,IAAI,EAAJ,qBAAuB,IA3BJ,8BAiCnBxB,EAAQ0F,IAAIlE,EAAS6E,GAEzB,MAAO,CAACH,OAAQ,EAAGI,UAAMI,EAAWpG,OAAQA,MAnIpD,4BAeI,SAAqBuG,EAAgBC,GAAiB,IAAD,gBAC/BA,GAD+B,IACjD,IAAI,EAAJ,qBAA2B,CAAC,IAApBC,EAAmB,QACvBF,EAAKG,UAAUD,EAAO5H,QAAQ4H,EAAOtI,KAFQ,iCAfzD,yBAqBI,SAAmBoI,EAAgB9B,GAAc,IAAD,gBAC5BA,GAD4B,IAC5C,IAAI,EAAJ,qBAAsB,CAAC,IAAfC,EAAc,sBACOA,EADP,GACbW,EADa,KACHC,EADG,KAElBiB,EAAKhB,QAAQF,EAAUC,IAHiB,mCArBpD,eAA6BI,MC2FhBiB,EAAb,kDAMI,aAAc,IAAD,8BACT,gBALJnH,YAA6B,KAIhB,EAHbG,aAAe,IAAI+F,IAGN,EAFb5F,cAAgB,IAAI4F,IAIhB,EAAKkB,aAAa,SAFT,EANjB,yCAWI,SAAM/H,GACFiF,KAAKtE,YAAcX,EAAQV,KAZnC,0BAeI,WACI,IAAM2D,EAAegC,KAAK+C,SAAS/C,KAAKhC,cACxC,GAAGA,EAAa,CACZ,IAAMmD,EAAYnB,KAAKgD,aAAahF,EAAamD,WAC9CA,IACCnB,KAAKmB,GAAWnD,EAAajD,SAC7BiD,EAAaoD,WAAY,EACzBpB,KAAKnE,aAAayF,IAAItD,EAAajD,QAAQV,GAAI2D,EAAajD,QAAQV,IACpE2F,KAAKhC,mBAvBrB,4BA4BI,SAAeiF,EAAY1E,EAAYpC,EAAWb,EAAeE,GAC7D,GAAGF,GAASE,EAIR,IAEsByH,EAAM1E,GAAxB,IAFD,EAIsB0E,EAAM1E,GAAKjD,EAAOE,EAAKW,GAAvCD,EAJN,EAIMA,OAAQgG,EAJd,EAIcA,KAGb,GAFAlC,KAAK9D,OAASA,EACd8D,KAAKhE,cAAc7B,QAChB+H,EAAK,CAAC,IAAD,gBACUA,GADV,IACJ,2BAAmB,CAAC,IAAXgB,EAAU,QACflD,KAAKhE,cAAcsF,IAAI4B,EAAGA,IAF1B,+BAKR,OAAOhH,EAEX,MAAM9B,GACF4E,QAAQC,IAAI7E,aAhD5B,GA1BA,kDAEI,aAAc,wCAFlB,UA3DA,iDACI+I,WAAa,IAAIvB,IADrB,KAEI1F,OAAS,IAAI0F,IAFjB,KAGI5D,aAAe,EAHnB,KAIIC,UAAoB,EAJxB,gDAMI,SAAakD,GACTnB,KAAKmD,WAAW7B,IAAIH,EAAWA,KAPvC,6BAUI,SAAgBzB,GACZ,IACI,IAAMyB,EAAYnB,KAAKgD,aAAatD,GAEpC,OADAM,KAAKmD,WAAWC,OAAO1D,GAChByB,EACT,MAAO/G,GAEL,OADA4E,QAAQC,IAAI7E,GACL,QAjBnB,0BAqBI,SAAasF,GACT,IACI,IAAIyB,EAAYnB,KAAKmD,WAAW9H,IAAIqE,GACpC,IAAIyB,EACA,MAAM,IAAIkC,MAAM,0BAEpB,OAAOlC,EACT,MAAM/G,GACJ,OAAO,QA7BnB,sBAkCI,SAASkJ,GACLtD,KAAK9D,OAAOoF,IAAItB,KAAK9D,OAAOC,KAAKmH,KAnCzC,yBAuCI,SAAY5D,GACR,IACI,IAAM4D,EAAQtD,KAAK+C,SAASrD,GAE5B,OADAM,KAAK9D,OAAOkH,OAAO1D,GACZ4D,EACT,MAAOlJ,GAEL,OADA4E,QAAQC,IAAI7E,GACL,QA9CnB,sBAkDI,SAASsF,GACL,IACI,OAAOM,KAAK9D,OAAOb,IAAIqE,GACzB,MAAMtF,GACJ,OAAO,UAtDnB,Q,SJlBK2D,O,sBAAAA,M,KAkBE,IA6CFwF,IA7CiBC,EAyBlB,WAAY9D,EAAe7C,EAAiBD,EAAgB2G,GAAY,IAAD,OAgBnE,OAhBmE,yBAxBvE7D,KAAe,UAwBwD,KAvBhEvD,KAAO,CACVU,OAAQ,GACRD,MAAO,IAqB4D,KAnBtE6G,MAAa,EAmByD,KAjBvEC,gBAAkC,WAI9B,IAHA,IAAIC,EAAa,IAAItC,EADe,EAEZ,EAAKlF,KACvBA,EAH8B,EAE7BU,OAF6B,EAErBD,MAEPsG,EAAI,EAAGA,GAAK/G,EAAM+G,IACtBS,EAAUf,UAAU,CAACzH,SAAS,GAC5B+H,GAGN,OADA,EAAK9H,UAAYuI,EACVA,GAQ4D,KALvEvI,UAAsB4E,KAAK0D,kBAK4C,KAJvEP,gBAIuE,OAHvES,WAAqB,MAGkD,KAFvEL,KAAYxF,EAKLlB,GAAUD,IACToD,KAAK7D,KAAKU,OAASA,EACnBmD,KAAK7D,KAAKS,MAAQA,GAGnB2G,IACCvD,KAAKuD,KAAOA,GAGb7D,IACCM,KAAKN,KAAOA,GAGTM,OAIVuD,Q,KAAAA,E,aAAAA,I,aAUE,IAAMM,EAAb,kDAKI,WAAYnE,EAAe7C,EAAiBD,GAAgB,IAAD,EAMvD,OANuD,qBACvD,cAAM8C,EAAM7C,EAAQD,EAAO2G,IAL/BhI,cAAwB,EAImC,EAH3DE,YAAqB,EAAKU,KAAKU,OAAO,EAAKV,KAAKS,MAGW,EAF3DjB,SAAW,IAAIkH,EAKX,EAAKa,kBAGE,8BAXf,UAAgCF,GK1EnBM,EAAQC,aCCE,WAAyB,IAAxBnJ,EAAuB,uDAAf,GAAIoJ,EAAW,uCAG3C,OAAOA,EAAO1J,MACV,KAAKT,EACD,OAAO,IAAIgK,EAAW,mBAAoBG,EAAOjJ,QAAQ8B,OAAQmH,EAAOjJ,QAAQ6B,OACpF,KAAK/C,EAQD,OAPaoK,YAAQrJ,GAAO,SAAAsJ,GACxBA,EAAWvI,SAASwI,eAAevJ,EAAMQ,UAAU8I,EAAWN,WAAYM,EAAW/H,KAAM+H,EAAW3I,cAAe2I,EAAWzI,aAChIyI,EAAWvI,SAASqC,aAAe,EACnCkG,EAAWvI,SAASE,aAAa1B,QACjC+J,EAAWvI,SAASsC,UAAW,EAC/BiG,EAAWvI,SAASD,YAAc,QAG1C,KAAK7B,EAGD,OADAe,EAAMe,SAASyI,eACRxJ,EACX,KAAKf,EAQD,OAPaoK,YAAQrJ,GAAO,SAAAsJ,GACxBA,EAAWvI,SAASsC,UAAW,EACQ,IAApCiG,EAAWvI,SAASO,OAAOC,MAC1B+H,EAAWvI,SAASwI,eAAevJ,EAAMQ,UAAU8I,EAAWN,WAAYM,EAAW/H,KAAM+H,EAAW3I,cAAe2I,EAAWzI,gBAK5I,KAAK5B,EAKD,OADAe,EAAMe,SAASsC,UAAW,EACnBrD,EACX,KAAKf,EACWoK,YAAQrJ,GAAO,SAAAsJ,GACvBA,EAAWvI,SAASqC,aAAe,EACnCkG,EAAWvI,SAASD,YAAc,KAClCwI,EAAWvI,SAASE,aAAa1B,QACjC+J,EAAWvI,SAASsC,UAAW,KAEvC,KAAKpE,EAUD,OATYoK,YAAQrJ,GAAO,SAAAsJ,GACvBA,EAAWvI,SAASqC,aAAe,EACnCkG,EAAWvI,SAASD,YAAc,KAClCwI,EAAWvI,SAASO,OAAO/B,QAC3B+J,EAAWvI,SAASK,cAAc7B,QAClC+J,EAAWvI,SAASE,aAAa1B,QACjC+J,EAAWvI,SAASsC,UAAW,KAIvC,KAAKpE,EAWD,OAVYoK,YAAQrJ,GAAO,SAAAsJ,GACvBA,EAAWN,WAAaI,EAAOjJ,QAAQwD,IACvC2F,EAAWvI,SAASqC,aAAe,EACnCkG,EAAWvI,SAASD,YAAc,KAClCwI,EAAWvI,SAASO,OAAO/B,QAC3B+J,EAAWvI,SAASK,cAAc7B,QAClC+J,EAAWvI,SAASE,aAAa1B,QACjC+J,EAAWvI,SAASsC,UAAW,KAIvC,KAAKpE,EAgBD,OAfaoK,YAAQrJ,GAAO,SAAAsJ,GACxBA,EAAW3I,cAAgByI,EAAOjJ,QAAQV,GAC1C,IAAIc,EAAU+I,EAAW9I,UAAUC,IAAI2I,EAAOjJ,QAAQV,IAAIU,QAAQI,SACnD,IAAZA,IACCA,GAAU,EAGV+I,EAAW9I,UAAUC,IAAI2I,EAAOjJ,QAAQV,IAAIU,QAAQI,QAAUA,GAE/D+I,EAAW5I,QAAU4I,EAAW1I,MAC/B0I,EAAW1I,IAAM,SAM7B,KAAK3B,EAaD,OAZYoK,YAAQrJ,GAAO,SAAAsJ,GACvBA,EAAWzI,YAAcuI,EAAOjJ,QAAQV,GACxC,IAAIc,EAAU+I,EAAW9I,UAAUC,IAAI2I,EAAOjJ,QAAQV,IAAIU,QAAQI,SACnD,IAAZA,IACCA,GAAU,EACV+I,EAAW9I,UAAUC,IAAI2I,EAAOjJ,QAAQV,IAAIU,QAAQI,QAAUA,GAG/D+I,EAAW5I,QAAU4I,EAAW1I,MAC/B0I,EAAW5I,MAAQ,SAI/B,KAAKzB,EAaD,OAZYoK,YAAQrJ,GAAO,SAAAsJ,GACvB,IAAIG,EAAOH,EAAW9I,UAAUC,IAAI2I,EAAOjJ,QAAQV,IACnDgK,EAAKtJ,QAAQI,SAAUkJ,EAAKtJ,QAAQI,QAEjC6I,EAAOjJ,QAAQV,KAAO6J,EAAW5I,MAChC4I,EAAW5I,MAAQ,KAEf0I,EAAOjJ,QAAQV,KAAO6J,EAAW1I,MACrC0I,EAAW1I,IAAM,SAK7B,QACI,OAAO,IAAIqI,EAAW,yBCrGV,uCAAG,4BAAAS,EAAA,6DACjBC,EAAcT,EAAMU,WAAU,YAEf,IADEV,EAAMW,WAAW9I,SAA7BsC,UAEHyG,uBAAsB,kBAAMZ,EAAMhJ,SAAS,CAACR,KAAMT,UAJnC,kBAOhB0K,GAPgB,2CAAH,qDAYPI,GAoBFC,MAlBf,WAEE,OADW5J,OAAOC,aAAa,KAE7B,qBAAKmB,UAAU,MAAMK,MAAO,CAC1BC,gBAAiB,UACjBG,OAAQ,QACRiC,MAAO,QACPJ,QAAS,QAJX,SAMI,eAAC,IAAD,CAAUoF,MAAOA,EAAjB,UACA,cAAC,EAAD,IACA,cAAC,EAAD,UCxBOe,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,cAEAC,IAASC,OAEP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bd,M","file":"static/js/main.e4ea850c.chunk.js","sourcesContent":["export const actions = {\r\n    //graph dimension actions\r\n    createGraph: \"createGraph\",\r\n    resetGraph: \"resetGraph\",\r\n\r\n    //graph painting user actions\r\n    setStart: \"setStart\",\r\n    setEnd: \"setEnd\",\r\n    blockOrUnblockCell: \"blockOrUnblockCell\",\r\n\r\n    //graph visualizer user actions\r\n    setAlg: \"setAlg\",\r\n    //everytime we set an algorithm we have to regenerate the animations\r\n\r\n    //animator actions\r\n    pause: \"pause\",\r\n    play: \"play\",\r\n    processNextFrame: \"getNext\",\r\n    generateFrames: \"generateFrames\",\r\n    clearFrames: \"clearFrames\",\r\n    resetAnimator: \"resetAnimator\"\r\n\r\n}\r\n\r\n","import React from \"react\";\r\nimport {connect, useSelector} from \"react-redux\";\r\nimport {actions} from \"../Redux/Actions/actionTypes\"\r\n\r\nfunction editCell (blockOrUnBlock: any, setStart: any, setEnd: any, clearFrames: any, clear: boolean) {\r\n    return (e: {button: number, buttons: number, preventDefault: () => void, type: string, ctrlKey: boolean },id: number) => {\r\n        if(e.type === 'mousedown' || e.type === \"mouseenter\"){\r\n            if(e.ctrlKey && e.buttons===1){\r\n                // console.log(\"block\", e.type, \"id\", id);\r\n                e.preventDefault();\r\n\r\n                blockOrUnBlock(id);\r\n                if(clear) clearFrames();\r\n            }\r\n        }\r\n        else if(e.type === \"contextmenu\"){\r\n            // console.log(\"set end\", e.type, \"rightClick\", \"id\", id);\r\n            e.preventDefault();\r\n            setEnd(id);\r\n            if(clear) clearFrames();\r\n        }\r\n        else if (e.type === 'click') {\r\n            if(e.button === 0 && !e.ctrlKey){\r\n                // console.log(\"set start\", e.type,\"leftClick\", \"id\", id);\r\n                setStart(id);\r\n                if(clear) clearFrames();\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nfunction Cell(props: {id: number, blockOrUnBlock?: any, setStart?: any, setEnd?: any, clearFrames?: any}): JSX.Element {\r\n    let nbsp = String.fromCharCode(160);\r\n    const {id} = props;\r\n\r\n    const {blocked, start, end, focusedNode, visited, inSolution, clearOnEdit} = useSelector(\r\n        (state: {gameboard: any, startVertexid: number, endVertexid: number, animator: any }) => {\r\n            return ({\r\n                blocked:  state.gameboard.get(id).payload.blocked,\r\n                start: state.startVertexid,\r\n                end: state.endVertexid,\r\n                focusedNode: state.animator.focusedNode,\r\n                visited: state.animator.visitedNodes.has(id),\r\n                inSolution: state.animator.solutionNodes.has(id),\r\n                clearOnEdit: state.animator.frames.size > 0\r\n            });\r\n        });\r\n\r\n    let getBackgroundColor = (blocked: boolean, start: number, end: number) => {\r\n        let backgroundColor = \"slategrey\";\r\n\r\n        if(end === focusedNode && inSolution && id!=start && id!=end){\r\n            backgroundColor = \"lightgreen\";\r\n        }\r\n        else if(id === focusedNode && end !==focusedNode){\r\n            backgroundColor = \"green\"\r\n        }\r\n        else if(start === id){\r\n            backgroundColor = \"yellow\"\r\n        }\r\n        else if(end === id) {\r\n            backgroundColor = \"orange\"\r\n        }\r\n        else if (visited) {\r\n            backgroundColor = \"lightblue\"\r\n        }\r\n        else if (blocked) {\r\n            backgroundColor = \"black\"\r\n        }\r\n        return backgroundColor;\r\n    }\r\n\r\n    return (\r\n        <div className={\"cell\"}\r\n             onContextMenu={(e) => editCell(props.blockOrUnBlock, props.setStart, props.setEnd, props.clearFrames, clearOnEdit)(e, id)}\r\n             onClick={(e) =>  editCell(props.blockOrUnBlock, props.setStart, props.setEnd, props.clearFrames, clearOnEdit)(e, id)}\r\n             onMouseDown={(e) =>  editCell(props.blockOrUnBlock, props.setStart, props.setEnd, props.clearFrames, clearOnEdit)(e, id)}\r\n             onMouseEnter={(e) =>  editCell(props.blockOrUnBlock, props.setStart, props.setEnd,props.clearFrames, clearOnEdit)(e, id)}\r\n             >\r\n            <div style={{\r\n                backgroundColor: getBackgroundColor(blocked, start, end),\r\n                width:  \"1vw\",\r\n                height: \"1vw\",\r\n                minHeight: \"15px\",\r\n                minWidth:\"15px\",\r\n                fontSize: \"10px\",\r\n                padding: \"0\",\r\n                margin: \"0\"\r\n            }}>\r\n                {start===id ? \"start\": \"\"}{end===id ? \"end\": \"\"}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n\r\nfunction mapStateToProps(state: any, props: {id: number, payload?: {blocked?: boolean} }): any {\r\n    return ({\r\n        ...props,\r\n    });\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any){\r\n    return ({\r\n        blockOrUnBlock: (id:number) => dispatch({type: actions.blockOrUnblockCell,payload: {id}}),\r\n        setStart: (id: number) => dispatch({type: actions.setStart, payload: {id}}),\r\n        setEnd: (id: number) => dispatch({type: actions.setEnd, payload: {id}}),\r\n        clearFrames: () => dispatch({type: actions.clearFrames})\r\n    });\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Cell);","import React from 'react';\r\nimport {connect} from \"react-redux\";\r\nimport Cell from \"./Cell\";\r\n\r\n//need to figure out a way to do this in nlogn or n\r\nfunction createRows(size: any){\r\n    let current = 0;\r\n    let rows = [];\r\n    let count:number = 1;\r\n\r\n    while(current < size.height){\r\n       let currentRow = [];\r\n       while(count <= (current + 1) * size.width){\r\n           let newCell: JSX.Element | null = <Cell id={count} key={count}></Cell>;\r\n           currentRow.push(newCell);\r\n           count++;\r\n           newCell = null;\r\n       }\r\n       rows.unshift(currentRow);\r\n       currentRow = [];\r\n       current++;\r\n    }\r\n\r\n    return rows.map((row,index) => {\r\n        return (\r\n            <div className={\"row\"} key={\"Row \" + index}>\r\n                {row}\r\n            </div>\r\n        );\r\n    });\r\n\r\n}\r\n\r\nfunction Graph (props: any): JSX.Element{\r\n    // const animator = useSelector((state: {animator: any}) => state.animator);\r\n    // console.log(animator);\r\n\r\n        return (\r\n            <div className=\"graph\" style={{marginRight: \"50px\"}}>\r\n                {createRows(props.size)}\r\n            </div>\r\n        );\r\n}\r\n\r\nfunction mapStateToProps(state: {size?: {height: number, width: number}, gameboard?: any}): any {\r\n    // console.log(state);\r\n    return ({\r\n        size: state.size,\r\n        // adjList: state.gameboard as IAdjList\r\n    });\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any){\r\n    return ({});\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Graph);","import React from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {useState} from \"react\";\r\nimport {actions} from \"../Redux/Actions/actionTypes\"\r\n\r\n\r\nfunction SideBar(props: any): JSX.Element {\r\n    const [size, setSize] = useState({height: 5, width: 5});\r\n\r\n    return (\r\n        <div>\r\n            {/*instructions*/}\r\n            <div style={{display: \"flex\"}}>\r\n                <ol style={{\r\n                    margin: \"0\",\r\n                    marginTop: \"15px\",\r\n                    marginLeft: \"50px\",\r\n                    padding: \"0\",\r\n                    textAlign: \"left\",\r\n                    color: \"red\"\r\n                }}>\r\n                    <li>Set Start\r\n                        <ul><li><span>Left-click a cell</span></li></ul>\r\n                    </li>\r\n                    <li>Set End\r\n                        <ul><li><span>Right-click a cell</span></li></ul>\r\n                    </li>\r\n                    <li>Block/Unblock Cells\r\n                        <ul><li><span>Left-click + Hold-down CTRL + drag cursor over cells</span></li></ul>\r\n                    </li>\r\n                </ol>\r\n            </div>\r\n\r\n            {/*dimensions*/}\r\n            <div style={{display: \"flex\", padding: \"0\"}} >\r\n                <form style={{\r\n                    margin: \"0\",\r\n                    padding: \"0\",\r\n                    marginTop: \"15px\",\r\n                    marginLeft: \"35px\",\r\n                }}\r\n                      onSubmit={ (e) => {\r\n                          console.log(\"Generated New Graph!\");\r\n                          e.preventDefault();\r\n                          props.createGameBoard(size);\r\n\r\n                      }}>\r\n                    <input style={{maxWidth: \"50px\", marginRight: \"5px\"}} type=\"text\" placeholder={\"height\"} onChange={(e) => {\r\n                            let newHeight = parseInt(e.target.value);\r\n                            setSize({...size, height: newHeight});\r\n                        }\r\n                    }/>\r\n                    <input style={{maxWidth: \"50px\", marginRight: \"5px\"}} type=\"text\" placeholder={\"width\"} onChange={(e) => {\r\n                            let newWidth = parseInt(e.target.value);\r\n                            setSize({...size, width: newWidth});\r\n                        }\r\n                    }/>\r\n                    <input type=\"submit\" value=\"Generate\"/>\r\n                </form>\r\n\r\n            </div>\r\n\r\n            {/*algorithm*/}\r\n\r\n            <div style={{display: \"flex\", padding: \"0\"}}>\r\n\r\n\r\n            </div>\r\n\r\n            {/*animations*/}\r\n            <div style={{display: \"flex\", padding: \"0\"}}>\r\n                <div style={{\r\n                    // display: \"flex\",\r\n                    // flexDirection: \"column\",\r\n                    // justifyContent: \"center\",\r\n                    margin: \"0\",\r\n                    padding: \"0\",\r\n                    marginTop: \"15px\",\r\n                    marginLeft: \"35px\"\r\n                }}\r\n                >\r\n                    <select name=\"algorithms\" onChange={(e) => props.setAlg(e.target.value)}>\r\n                        <option value=\"bfs\">bfs</option>\r\n                        <option value=\"dfs\">dfs</option>\r\n                        <option value=\"Bi-Dir\">Bi-Dir</option>\r\n                    </select>\r\n                </div>\r\n                <div style={{\r\n                    // display: \"flex\",\r\n                    // flexDirection: \"column\",\r\n                    // justifyContent: \"center\",\r\n                    margin: \"0\",\r\n                    padding: \"0\",\r\n                    marginTop: \"15px\",\r\n                    marginLeft: \"5px\"\r\n                }}>\r\n                    <button onClick={props.play}>Play</button>\r\n                    <button onClick={props.pause}>Pause</button>\r\n                    <button onClick={props.resetAnimator}>Reset</button>\r\n                    {/*<button onClick={props.processNext}>Next</button>*/}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction mapStateToProps(state: {size: {height: number, width: number}, animator: {currentFrame: number, isPaused: boolean}}): any {\r\n    return ({\r\n        size: state.size,\r\n        currentFrame: state.animator.currentFrame,\r\n        isPaused: state.animator.isPaused\r\n    });\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any){\r\n    return ({\r\n        createGameBoard: (size: {height: number, width: number}) => dispatch({type: actions.createGraph, payload: {...size}}),\r\n        pause: () => dispatch({type: actions.pause}),\r\n        play: () => {dispatch({type: actions.play})},\r\n        // generateFrames: () => dispatch({type: actions.generateFrames})\r\n        resetAnimator: () => dispatch({type: actions.resetAnimator}),\r\n        setAlg: (alg:string) => dispatch({type: actions.setAlg, payload: {alg: alg}})\r\n    });\r\n}\r\n\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(SideBar);\r\n\r\n","import {IAdjList, AdjList} from \"../AdjList/AdjList\";\r\nimport {immerable} from \"immer\";\r\nimport {IAnimator, Animator, GraphAnimator} from \"../Animations/Animator\";\r\n\r\nenum defAlgs {\r\n    default\r\n}\r\n\r\nexport interface IVisualizerCore {\r\n    name: string;\r\n    size: {\r\n        height: number;\r\n        width: number;\r\n    }\r\n    gameboard: IAdjList;\r\n\r\n    algs?: any;\r\n    currentAlg: string;\r\n\r\n    animator?: GraphAnimator;\r\n}\r\n\r\nexport abstract class AbsVisualizer implements IVisualizerCore {\r\n    name: string = \"default\";\r\n    public size = {\r\n        height: 20,\r\n        width: 20\r\n    };\r\n    [immerable] = true;\r\n\r\n    createGameboard: () => IAdjList = () => {\r\n        let gameBoard =  new AdjList();\r\n        const {height, width} = this.size;\r\n        const size = height * width;\r\n        for(let i = 1; i <= size; i++){\r\n            gameBoard.addVertex({blocked: false\r\n            },i);\r\n        }\r\n        this.gameboard = gameBoard;\r\n        return gameBoard;\r\n    }\r\n\r\n    gameboard: IAdjList = this.createGameboard();\r\n    animations?: IAnimator;\r\n    currentAlg: string = \"bfs\";\r\n    algs: any = defAlgs;\r\n\r\n    constructor(name?: string, height?: number, width?: number, algs?: any){\r\n        // console.log(height, width);\r\n\r\n        if(height && width){\r\n            this.size.height = height;\r\n            this.size.width = width;\r\n        }\r\n\r\n        if(algs){\r\n            this.algs = algs;\r\n        }\r\n\r\n        if(name){\r\n            this.name = name;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nenum algs {\r\n    BFS,\r\n    DFS,\r\n}\r\n\r\ninterface IVisualizer extends AbsVisualizer {\r\n    startVertexid?: number;\r\n    endVertexid?: number;\r\n}\r\n\r\nexport class Visualizer extends AbsVisualizer implements IVisualizer{\r\n    startVertexid: number = 1;\r\n    endVertexid:number = this.size.height*this.size.width;\r\n    animator = new GraphAnimator();\r\n\r\n    constructor(name?: string, height?: number, width?: number){\r\n        super(name, height, width, algs);\r\n\r\n        this.createGameboard();\r\n        // this.animator.generateFrames(this.gameboard, \"BFS\", this.size, this.startVertexid, this.endVertexid);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n\r\n\r\n","import {IAdjList} from \"../AdjList/AdjList\";\r\n\r\nexport interface IVertex{\r\n    id: number;\r\n    payload: {blocked?: boolean};\r\n    edges?: number[];\r\n    addEdge: (edge: number) => void;\r\n    removeEdge: (edge: number) => void;\r\n}\r\n\r\nexport class Vertex implements IVertex {\r\n    payload = {blocked: false};\r\n    id: number = -1;\r\n    edges?: number[] = [];\r\n\r\n    constructor(payload: any, id: number) {\r\n            this.payload = payload;\r\n            this.id = id;\r\n        }\r\n\r\n    addEdge(edge: number){\r\n        try{\r\n            if(this.edges){\r\n                this.edges.push(edge);\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log(e);\r\n        }\r\n    }\r\n\r\n    removeEdge(edge: number){\r\n        try{\r\n            if(this.edges){\r\n                this.edges = this.edges.filter(vEdge => vEdge !== edge);\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.log(e);\r\n        }\r\n\r\n    }\r\n\r\n    public get Edges(){\r\n        return this.edges;\r\n    }\r\n\r\n    public static getCoordinates(vertexId: number, height: number, width: number){\r\n        let y: number = Math.ceil(vertexId/width);\r\n        let x: number = width - (y*width - vertexId);\r\n        return {x, y};\r\n    }\r\n}\r\n\r\nexport interface IVisualizerVertex extends IVertex{\r\n    getEdges(size: {height: number, width: number},adjList: IAdjList): any[];\r\n}\r\n\r\nexport class VisualizerVertex extends Vertex implements IVisualizerVertex {\r\n    public getEdges(size: {height: number, width: number}, adjList: IAdjList){\r\n       const {height, width} = size;\r\n       let gameEdges: number[] = [];\r\n        // let edgeCoordinates: {x: number, y: number}[] = [];\r\n        //possible edges\r\n        //possibly need to exclude diags\r\n        /*\r\n           1. (x+1,y)\r\n           2. (x-1,y)\r\n           3. (x,y+1)\r\n           4. (x-1,y+1) --excluded\r\n           5. (x+1,y+1) --excluded\r\n           6. (x, y-1)\r\n           7. (x-1,y-1) --excluded\r\n           8. (x+1,y-1) --excluded\r\n        */\r\n\r\n        let curr_coordinates = VisualizerVertex.getCoordinates(this.id, height, width);\r\n        let {x,y} = curr_coordinates;\r\n        let {blocked} = this.payload;\r\n\r\n        //right\r\n        // edgeCoordinates.push({x: x + 1, y: y});\r\n        let right = (x+1)+((y-1)*width);\r\n\r\n        if(!blocked){\r\n                if(right < height*width+1 && right <= y*width){\r\n                    let rightBlocked = adjList.get(right);\r\n                    if(rightBlocked && !rightBlocked.payload.blocked){\r\n                        gameEdges.push(right);\r\n                    }\r\n\r\n                }\r\n        }\r\n\r\n        //left\r\n        // edgeCoordinates.push({x:  x - 1, y: y});\r\n        let left = (x-1)+((y-1)*width);\r\n        if(!blocked){\r\n            let leftBlocked = adjList.get(left);\r\n            if(left > 0 && left > (y-1)*width){\r\n                if(leftBlocked && !leftBlocked.payload.blocked){\r\n                    gameEdges.push(left);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        //top\r\n        // edgeCoordinates.push({x:  x, y:  y + 1});\r\n        let top = x+((y)*width);\r\n        if(!blocked){\r\n            let topBlocked = adjList.get(top);\r\n            if(top < height*width+1){\r\n                if(topBlocked && !topBlocked.payload.blocked){\r\n                    gameEdges.push(top);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        //bottom\r\n        // edgeCoordinates.push({x:  x, y: y - 1});\r\n        let bottom = x+((y-2)*width);\r\n        if(!blocked){\r\n            let bottomBlocked = adjList.get(bottom);\r\n            if(bottom > 0){\r\n                if(bottomBlocked && !bottomBlocked.payload.blocked){\r\n                    gameEdges.push(bottom);\r\n                }\r\n            }\r\n        }\r\n\r\n        // const {x, y} = VisVertex.getCoordinates(this.id, )\r\n        return gameEdges;\r\n    }\r\n}","export interface IFrame {\r\n    processed: boolean;\r\n    payload: any;\r\n    animation: string;\r\n}\r\n\r\nexport class Frame implements IFrame {\r\n    processed: boolean = false;\r\n    animation = \"default\";\r\n    payload = {};\r\n\r\n    constructor(animation: string, payload: any) {\r\n        this.payload = payload;\r\n        this.animation = animation;\r\n    }\r\n}","import {IVisualizerVertex, VisualizerVertex} from \"../Vertex/Vertex\";\r\nimport {Frame} from \"../Animations/Frame\";\r\n\r\nexport interface IAdjList extends Map<number,IVisualizerVertex>{\r\n    addVertex: (payload: any, id: number) => void;\r\n    addEdge: (vertexID: number, edgeID: number) => void;\r\n    removeEdge: (vertexID: number, edgeID: number) => void;\r\n\r\n    bfs(startID: number, end:number, size?: {height: number, width: number}): any;\r\n    dfs(startID: number, end:number, size?: {height: number, width: number}): any;\r\n    // dfs?: (startID: number, findID:number, blockedids?:  Map<number,number>, size?: {height: number, width: number}) => {length: number, path?: number[]};\r\n\r\n    // biDir?: (startID: number, findID:number) => {length: number, path?: number[]};\r\n    \r\n}\r\n\r\nexport class AdjList extends Map implements IAdjList{\r\n    [s: string]: any;\r\n\r\n    addVertex(payload: any, id: number){\r\n        this.set(id, new VisualizerVertex(payload, id));\r\n    }\r\n\r\n    addEdge(vertexID: number, edgeID: number){\r\n        this.get(vertexID).addEdge(edgeID);\r\n    }\r\n\r\n    removeEdge(vertexID: number, edgeID: number){\r\n        this.get(vertexID).removeEdge(edgeID);\r\n    }\r\n\r\n    static vertexFactory(list: IAdjList, vertices: any[]){\r\n        for(let vertex of vertices){\r\n            list.addVertex(vertex.payload,vertex.id);\r\n        }\r\n    };\r\n\r\n    static edgeFactory(list: IAdjList, edges: any[]){\r\n        for(let edge of edges){\r\n            let [vertexID, edgeID] = edge;\r\n            list.addEdge(vertexID, edgeID);\r\n        }\r\n    };\r\n\r\n    public bfs(startID: number, end:number, size?: {height: number, width: number}){\r\n        // console.log(this);\r\n        let visited = new Map();\r\n        type queueItem = number[];\r\n        let queue: queueItem[] = [];\r\n\r\n\r\n        let frames = new Map<number, Frame>();\r\n\r\n        //push the start vertex\r\n        queue.push([startID, -1]);\r\n\r\n\r\n        //while the queue has items\r\n        while(queue.length > 0){\r\n            //dequeue last item\r\n            let queuedItem = queue.pop();\r\n\r\n            //get currentIndex and lastIndex if they exist\r\n            let current, last = null;\r\n            if(queuedItem){\r\n                [current, last] = queuedItem;\r\n            }\r\n\r\n            if(current != null){\r\n                frames.set(frames.size, new Frame(\"focus\", {id: current}));\r\n            }\r\n\r\n            //if the desired vertex is found print the path\r\n            if(current == end){\r\n                let path = [current];\r\n\r\n                while(last > -1){\r\n                    path.unshift(last);\r\n                    last = visited.get(last);\r\n                }\r\n                return {length: path.length, path: path, frames: frames};\r\n            }\r\n\r\n            //for each of the edges in this iteration\r\n            let edges;\r\n            if(size){\r\n                edges = this.get(current).getEdges(size, this);\r\n            }\r\n            for(let edge of edges){\r\n                //if the edge is not visited and the edge is not queued queue\r\n                if(!visited.has(edge) && !queue.some(item => item[0]===edge)){\r\n                        queue.unshift([edge,current]);\r\n                }\r\n            }\r\n            //set focus animation\r\n            visited.set(current, last);\r\n        }\r\n        return {length: 0, path: undefined, frames: frames};\r\n    }\r\n\r\n\r\n    dfs(startID: number, end:number, size?: {height: number, width: number}){\r\n        let visited = new Map();\r\n        type stackItem = number[];\r\n        let stack: stackItem[] = [];\r\n\r\n        let frames = new Map<number, Frame>();\r\n\r\n        //push the start vertex\r\n        stack.push([startID, -1]);\r\n\r\n        //while the queue has items\r\n        while(stack.length > 0){\r\n            //dequeue last item\r\n            let stackedItem = stack.pop();\r\n            // console.log(stackedItem);\r\n\r\n            //get currentIndex and lastIndex if they exist\r\n            let current, last;\r\n            if(stackedItem){\r\n                [current, last] = stackedItem;\r\n            }\r\n\r\n            if(current != null){\r\n                frames.set(frames.size, new Frame(\"focus\", {id: current}));\r\n            }\r\n\r\n            //if the desired vertex is found print the path\r\n            if(current == end){\r\n                let path = [current];\r\n                while(last > -1){\r\n                    path.unshift(last);\r\n                    last = visited.get(last);\r\n                }\r\n                return {length: path.length, path: path, frames: frames};\r\n            }\r\n\r\n            //for each of the edges in this iteration\r\n            let edges = this.get(current).getEdges(size, this);\r\n            for(let edge of edges){\r\n                //if the edge is not visited and the edge is not queued queue\r\n                if(!visited.has(edge) && !stack.some(item => item[0]===edge)){\r\n                    stack.push([edge,current]);\r\n                }\r\n            }\r\n            visited.set(current, last);\r\n        }\r\n        return {length: 0, path: undefined, frames: frames};\r\n    }\r\n\r\n\r\n}\r\n","import {IFrame} from \"./Frame\";\r\nimport {IAdjList} from \"../AdjList/AdjList\";\r\n\r\nexport interface IAnimator {\r\n    //animations\r\n    animations?: Map<string, string>\r\n    getAnimation?: (name: string) => string | null;\r\n\r\n    //nn\r\n        addAnimation?: (animation: string) => void;\r\n        removeAnimation?: (name: string) => string | null;\r\n\r\n    //frames\r\n    currentFrame?: number; //maybe create a getter?\r\n    frames?: Map<number, IFrame>;\r\n    addFrame?: (frame: IFrame) => void;\r\n    removeFrame?: (name: number) => IFrame | null;\r\n    getFrame?: (name: number) => IFrame | null;\r\n\r\n    isPaused: boolean;\r\n}\r\n\r\nexport abstract class AbsAnimator implements IAnimator {\r\n    animations = new Map<string,string>();\r\n    frames = new Map();\r\n    currentFrame = 0;\r\n    isPaused: boolean = true;\r\n\r\n    addAnimation(animation: string){\r\n        this.animations.set(animation, animation);\r\n    }\r\n\r\n    removeAnimation(name: string){\r\n        try{\r\n            const animation = this.getAnimation(name);\r\n            this.animations.delete(name);\r\n            return animation;\r\n        } catch (e) {\r\n            console.log(e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    getAnimation(name: string): string | null {\r\n        try {\r\n            let animation = this.animations.get(name);\r\n            if(!animation){\r\n                throw new Error(\"animation doesnt exist\");\r\n            }\r\n            return animation;\r\n        } catch(e) {\r\n            return null;\r\n        }\r\n\r\n    }\r\n\r\n    addFrame(frame: IFrame){\r\n        this.frames.set(this.frames.size,frame);\r\n\r\n    }\r\n\r\n    removeFrame(name: number){\r\n        try{\r\n            const frame = this.getFrame(name);\r\n            this.frames.delete(name);\r\n            return frame;\r\n        } catch (e) {\r\n            console.log(e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    getFrame(name: number): IFrame | null {\r\n        try {\r\n            return this.frames.get(name);\r\n        } catch(e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nexport class Animator extends AbsAnimator {\r\n    //implementation goes here\r\n    constructor(){\r\n        super();\r\n    }\r\n}\r\n\r\nexport interface IGraphAnimator extends IAnimator {\r\n    processFrame: (name: number) => void;\r\n    focusedNode: number | null;\r\n\r\n    //unimplemented\r\n    visitedNodes?: Map<number, number>;\r\n    solutionNodes?: Map<number, number>;\r\n\r\n    //animations\r\n    //focus (and set visit)\r\n    //solve (i.e., set solution)\r\n\r\n\r\n    //utility\r\n    //sets current frame to 0, clears visited, clears solution, regenerates frames\r\n    reset?: () => void;\r\n    generateFrames?: (graph: IAdjList, searchAlg: string,size: any, start: number, end: number) => void;\r\n}\r\n\r\nexport class GraphAnimator extends Animator implements IGraphAnimator{\r\n    [s: string]: null | any;\r\n    focusedNode: number | null = null;\r\n    visitedNodes = new Map<number, number>();\r\n    solutionNodes = new Map<number, number>();\r\n\r\n    constructor(){\r\n        super();\r\n        this.addAnimation(\"focus\");\r\n    }\r\n\r\n    focus(payload: {id: number}){\r\n        this.focusedNode = payload.id;\r\n    }\r\n\r\n    processFrame(){\r\n        const currentFrame = this.getFrame(this.currentFrame);\r\n        if(currentFrame){\r\n            const animation = this.getAnimation(currentFrame.animation);\r\n            if(animation){\r\n                this[animation](currentFrame.payload);\r\n                currentFrame.processed = true;\r\n                this.visitedNodes.set(currentFrame.payload.id, currentFrame.payload.id);\r\n                this.currentFrame++;\r\n            }\r\n        }\r\n    }\r\n\r\n    generateFrames(graph: any, alg:string, size: any, start: number, end: number){\r\n        if(start && end){\r\n            // if(alg = \"bfs\"){\r\n            //\r\n            // }\r\n            try{\r\n                // if(typeof graph[alg])\r\n                let algFunction = graph[alg];\r\n                // console.log(graph[alg](start, end, size));\r\n                let {frames, path} = graph[alg](start, end, size);\r\n                this.frames = frames;\r\n                this.solutionNodes.clear();\r\n                if(path){\r\n                    for (let i of path){\r\n                        this.solutionNodes.set(i, i);\r\n                    }\r\n                }\r\n                return frames;\r\n            }\r\n            catch(e){\r\n                console.log(e);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n// bfs(startID: number, findID:number, size?: {height: number, width: number}){\r\n//     animations?animations.push(new Animation(\"test\", ()=>{})):\"\";\r\n//\r\n//     let visited = new Map();\r\n//     type queueItem = number[];\r\n//     let queue: queueItem[] = [];\r\n//\r\n//     //push the start vertex\r\n//     queue.push([startID, -1]);\r\n//\r\n//     //while the queue has items\r\n//     while(queue.length > 0){\r\n//         //dequeue last item\r\n//         let queuedItem = queue.pop();\r\n//\r\n//         //get currentIndex and lastIndex if they exist\r\n//         let current, last;\r\n//         if(queuedItem){\r\n//             [current, last] = queuedItem;\r\n//         }\r\n//\r\n//         //if the desired vertex is found print the path\r\n//         if(current == findID){\r\n//             let path = [current];\r\n//             while(last > -1){\r\n//                 path.unshift(last);\r\n//                 last = visited.get(last);\r\n//             }\r\n//             return {length: path.length, path: path};\r\n//         }\r\n//\r\n//         //for each of the edges in this iteration\r\n//         let edges = this.get(current).getEdges(size, blockedids);\r\n//         for(let edge of edges){\r\n//             //if the edge is not visited and the edge is not queued queue\r\n//             if(!visited.has(edge) && !queue.some(item => item[0]===edge)){\r\n//                 queue.unshift([edge,current]);\r\n//             }\r\n//         }\r\n//         visited.set(current, last);\r\n//     }\r\n//     return {length: 0};\r\n// }","import { createStore } from 'redux';\r\nimport {reducer} from \"../Reducer/reducer\";\r\n\r\nexport const store = createStore(reducer, /* preloadedState, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()*/);","import produce from \"immer\";\r\nimport {actions} from \"../Actions/actionTypes\"\r\nimport {Visualizer} from \"../../Helpers/Visualizer/Visualizer\";\r\n\r\nexport const reducer = (state = {}, action) => {\r\n    let nextState;\r\n    // console.log(state);\r\n    switch(action.type) {\r\n        case actions.createGraph:\r\n            return new Visualizer(\"Graph Visualizer\", action.payload.height, action.payload.width);\r\n        case actions.generateFrames:\r\n            nextState  = produce(state, draftState => {\r\n                draftState.animator.generateFrames(state.gameboard,draftState.currentAlg, draftState.size, draftState.startVertexid, draftState.endVertexid);\r\n                draftState.animator.currentFrame = 0;\r\n                draftState.animator.visitedNodes.clear();\r\n                draftState.animator.isPaused = true;\r\n                draftState.animator.focusedNode = null;\r\n            })\r\n            return nextState;\r\n        case actions.processNextFrame:\r\n            //removed immer wrapper to try to address slowness to no avail.\r\n            state.animator.processFrame();\r\n            return state;\r\n        case actions.play:\r\n            nextState  = produce(state, draftState => {\r\n                draftState.animator.isPaused = false\r\n                if(draftState.animator.frames.size === 0){\r\n                    draftState.animator.generateFrames(state.gameboard,draftState.currentAlg, draftState.size, draftState.startVertexid, draftState.endVertexid);\r\n                }\r\n            })\r\n\r\n            return nextState;\r\n        case actions.pause:\r\n            // nextState  = produce(state, draftState => {\r\n            //     draftState.animator.isPaused = true;\r\n            // })\r\n            state.animator.isPaused = true;\r\n            return state;\r\n        case actions.resetAnimator:\r\n            nextState = produce(state, draftState => {\r\n                draftState.animator.currentFrame = 0;\r\n                draftState.animator.focusedNode = null;\r\n                draftState.animator.visitedNodes.clear();\r\n                draftState.animator.isPaused = true;\r\n            })\r\n        case actions.clearFrames:\r\n            nextState = produce(state, draftState => {\r\n                draftState.animator.currentFrame = 0;\r\n                draftState.animator.focusedNode = null;\r\n                draftState.animator.frames.clear();\r\n                draftState.animator.solutionNodes.clear()\r\n                draftState.animator.visitedNodes.clear();\r\n                draftState.animator.isPaused = true;\r\n            })\r\n\r\n            return nextState;\r\n        case actions.setAlg:\r\n            nextState = produce(state, draftState => {\r\n                draftState.currentAlg = action.payload.alg;\r\n                draftState.animator.currentFrame = 0;\r\n                draftState.animator.focusedNode = null;\r\n                draftState.animator.frames.clear();\r\n                draftState.animator.solutionNodes.clear()\r\n                draftState.animator.visitedNodes.clear();\r\n                draftState.animator.isPaused = true;\r\n            })\r\n            // console.log(nextState);\r\n            return nextState;\r\n        case actions.setStart:\r\n            nextState  = produce(state, draftState => {\r\n                draftState.startVertexid = action.payload.id;\r\n                let blocked = draftState.gameboard.get(action.payload.id).payload.blocked;\r\n                if(blocked === true){\r\n                    blocked = false;\r\n\r\n                    //need to reset as bool is immutable\r\n                    draftState.gameboard.get(action.payload.id).payload.blocked = blocked;\r\n                }\r\n                if(draftState.start === draftState.end){\r\n                    draftState.end = null;\r\n                }\r\n\r\n            })\r\n            // console.log(nextState);\r\n            return nextState;\r\n        case actions.setEnd:\r\n            nextState = produce(state, draftState => {\r\n                draftState.endVertexid = action.payload.id;\r\n                let blocked = draftState.gameboard.get(action.payload.id).payload.blocked;\r\n                if(blocked === true){\r\n                    blocked = false;\r\n                    draftState.gameboard.get(action.payload.id).payload.blocked = blocked;\r\n                }\r\n\r\n                if(draftState.start === draftState.end){\r\n                    draftState.start = null;\r\n                }\r\n            })\r\n            return nextState;\r\n        case actions.blockOrUnblockCell:\r\n            nextState = produce(state, draftState => {\r\n                let node = draftState.gameboard.get(action.payload.id);\r\n                node.payload.blocked = node.payload.blocked? false: true;\r\n                // console.log(\"reducer\", node.payload.blocked);\r\n                if(action.payload.id === draftState.start){\r\n                    draftState.start = null;\r\n                }\r\n                else if(action.payload.id === draftState.end){\r\n                    draftState.end = null;\r\n                }\r\n            });\r\n            // console.log(nextState);\r\n            return nextState;\r\n        default:\r\n            return new Visualizer(\"Graph Visualizer\");\r\n    }\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport Graph from \"./Components/Graph\";\r\nimport SideBar from \"./Components/SideBar\";\r\nimport {store} from \"./Redux/Store/store\";\r\nimport {Provider} from \"react-redux\";\r\nimport {actions} from \"./Redux/Actions/actionTypes\";\r\n\r\n\r\n//this is used to play and pause without having to rely on the useEffect Hook\r\n//request animation frame is used instead of setTimeout as it fails around 10ms.\r\n//when the condition is satisfied an action is dispatched that calls\r\n// the reducer that processes the next frame\r\nlet animatorEventTrigger = async () => {\r\n    const unsubscribe = store.subscribe(() => {\r\n        const {isPaused} = store.getState().animator;\r\n        if (isPaused === false) {\r\n            requestAnimationFrame(() => store.dispatch({type: actions.processNextFrame}))\r\n        }\r\n    });\r\n    return unsubscribe;\r\n}\r\n\r\n//used to envoke Trigger\r\n//returns a lamda that unsuscribes from the reduxStore\r\nlet unsuscribe = animatorEventTrigger();\r\n\r\nfunction App(): JSX.Element {\r\n  let nbsp = String.fromCharCode(160);\r\n  return (\r\n    <div className=\"App\" style={{\r\n      backgroundColor: \"#282c34\",\r\n      height: \"100vh\",\r\n      color: \"white\",\r\n      display: \"flex\"\r\n    }}>\r\n        <Provider store={store}>\r\n        <SideBar></SideBar>\r\n        <Graph></Graph>\r\n        </Provider>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport {enableMapSet} from \"immer\";\r\n\r\nenableMapSet();\r\n\r\nReactDOM.render(\r\n\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}